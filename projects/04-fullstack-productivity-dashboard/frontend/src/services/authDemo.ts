/**
 * Authentication Flow Demo & Testing
 * 
 * Demonstrates the complete authentication flow:
 * ğŸ”‘ Login Form â†’ Validate Credentials â†’ Generate JWT Token â†’ Store Token
 *      â†‘                                                        â†“
 * ğŸ›¡ï¸ Protected Access â† Verify Token â† Middleware Check â† Include in Headers
 */

import { AuthFlow, TokenManager, AuthGuard, authUtils } from './authFlow';
import { httpClient } from './httpClient';
import { store } from '../store';

// ========================================
// ğŸ§ª AUTHENTICATION FLOW DEMOS
// ========================================

export class AuthFlowDemo {
  /**
   * Demo 1: Complete Login Flow
   * Shows the full authentication cycle from form submission to token storage
   */
  static async demoLoginFlow(): Promise<void> {
    console.group('ğŸ”‘ DEMO: Complete Authentication Login Flow');
    
    try {
      console.log('ğŸ“‹ Step 1: User fills login form');
      const loginCredentials = {
        email: 'demo@example.com',
        password: 'securepassword123',
        rememberMe: true,
      };

      console.log('âœ… Step 2: Form validation passed');
      console.log('ğŸ“¤ Step 3: Sending credentials to server...');

      // This would normally come from form submission
      const loginResult = await AuthFlow.login(loginCredentials);

      if (loginResult.success) {
        console.log('ğŸ‰ Step 4: Login successful!');
        console.log('ğŸ”’ Step 5: JWT Token generated by server');
        console.log('ğŸ’¾ Step 6: Token stored in browser storage');
        
        // Show stored authentication data
        const storedData = TokenManager.getStoredTokens();
        console.log('ğŸ“Š Stored Authentication Data:', {
          hasToken: !!storedData.accessToken,
          hasRefreshToken: !!storedData.refreshToken,
          user: storedData.user?.email,
          expiresAt: storedData.expiryTime ? new Date(storedData.expiryTime).toLocaleString() : null,
        });

        // Show Redux state update
        const authState = store.getState().auth;
        console.log('ğŸ”„ Redux State Updated:', {
          isAuthenticated: authState.isAuthenticated,
          userEmail: authState.user?.email,
          hasToken: !!authState.token,
        });

        console.log('âœ… DEMO RESULT: Complete login flow successful');
      } else {
        console.log('âŒ DEMO RESULT: Login failed -', loginResult.error);
      }

    } catch (error) {
      console.error('ğŸ’¥ DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 2: Protected Access Flow  
   * Shows how authentication middleware handles protected requests
   */
  static async demoProtectedAccessFlow(): Promise<void> {
    console.group('ğŸ›¡ï¸ DEMO: Protected Access Flow');

    try {
      console.log('ğŸ“‹ Step 1: User attempts to access protected resource');
      console.log('ğŸ” Step 2: Middleware checks authentication...');

      // Check authentication status
      const isAuthenticated = AuthFlow.isAuthenticated();
      console.log('ğŸ” Authentication Status:', isAuthenticated);

      if (!isAuthenticated) {
        console.log('âŒ Step 3: User not authenticated - redirecting to login');
        console.log('âœ… DEMO RESULT: Protected access denied (as expected)');
        console.groupEnd();
        return;
      }

      console.log('âœ… Step 3: User is authenticated');
      console.log('ğŸ“¤ Step 4: Making request with auth headers...');

      // Make a protected API request
      const response = await httpClient.get('/protected-resource');

      if (response.success) {
        console.log('ğŸ‰ Step 5: Protected resource accessed successfully');
        console.log('ğŸ“Š Response:', response.data);
        console.log('âœ… DEMO RESULT: Protected access granted');
      } else {
        console.log('âŒ Step 5: Protected resource access failed');
        console.log('ğŸ“Š Error:', response.error);
        
        if (response.error?.includes('401')) {
          console.log('ğŸ”„ Step 6: Token might be expired, attempting refresh...');
          const refreshed = await AuthFlow.refreshTokens();
          if (refreshed) {
            console.log('âœ… Step 7: Token refreshed, access should work now');
          } else {
            console.log('âŒ Step 7: Token refresh failed, user needs to login again');
          }
        }
      }

    } catch (error) {
      console.error('ğŸ’¥ DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 3: Token Refresh Flow
   * Shows automatic token refresh when approaching expiry
   */
  static async demoTokenRefreshFlow(): Promise<void> {
    console.group('ğŸ”„ DEMO: Token Refresh Flow');

    try {
      const storedData = TokenManager.getStoredTokens();
      
      if (!storedData.accessToken) {
        console.log('âŒ No access token found - login required first');
        console.groupEnd();
        return;
      }

      console.log('ğŸ“‹ Step 1: Checking token expiry status...');
      const isExpired = TokenManager.isTokenExpired();
      console.log('â° Token Expired:', isExpired);

      if (isExpired) {
        console.log('ğŸ”„ Step 2: Token expired, attempting automatic refresh...');
        const refreshResult = await AuthFlow.refreshTokens();

        if (refreshResult) {
          console.log('âœ… Step 3: Token refresh successful');
          
          const newStoredData = TokenManager.getStoredTokens();
          console.log('ğŸ“Š New Token Info:', {
            hasNewToken: !!newStoredData.accessToken,
            newExpiryTime: newStoredData.expiryTime ? new Date(newStoredData.expiryTime).toLocaleString() : null,
          });

          console.log('âœ… DEMO RESULT: Token refresh completed successfully');
        } else {
          console.log('âŒ Step 3: Token refresh failed');
          console.log('ğŸ”“ Step 4: Clearing authentication state...');
          TokenManager.clearTokens();
          console.log('âŒ DEMO RESULT: Authentication session ended');
        }
      } else {
        console.log('âœ… Token is still valid, no refresh needed');
        const timeUntilExpiry = storedData.expiryTime ? (storedData.expiryTime - Date.now()) / 1000 / 60 : 0;
        console.log(`â° Time until expiry: ${Math.round(timeUntilExpiry)} minutes`);
        console.log('âœ… DEMO RESULT: Token refresh not needed yet');
      }

    } catch (error) {
      console.error('ğŸ’¥ DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 4: Role-Based Access Control
   * Shows permission checking for different user roles
   */
  static async demoRoleBasedAccess(): Promise<void> {
    console.group('ğŸ” DEMO: Role-Based Access Control');

    try {
      const currentUser = AuthFlow.getCurrentUser();
      
      if (!currentUser) {
        console.log('âŒ No authenticated user found');
        console.groupEnd();
        return;
      }

      console.log('ğŸ‘¤ Current User:', {
        name: currentUser.name,
        email: currentUser.email,
        role: currentUser.role,
      });

      // Test different permission levels
      const permissions = ['user', 'admin', 'moderator'];
      
      for (const permission of permissions) {
        console.log(`ğŸ” Testing access for role: ${permission}`);
        const hasAccess = await AuthGuard.canAccess(permission);
        console.log(`${hasAccess ? 'âœ…' : 'âŒ'} Access ${permission}: ${hasAccess ? 'GRANTED' : 'DENIED'}`);
      }

      console.log('âœ… DEMO RESULT: Role-based access control tested');

    } catch (error) {
      console.error('ğŸ’¥ DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 5: Complete Logout Flow
   * Shows proper cleanup of authentication state
   */
  static async demoLogoutFlow(): Promise<void> {
    console.group('ğŸ”“ DEMO: Logout Flow');

    try {
      console.log('ğŸ“‹ Step 1: User initiates logout');
      
      const beforeLogout = {
        hasToken: !!TokenManager.getStoredTokens().accessToken,
        isAuthenticated: AuthFlow.isAuthenticated(),
        reduxAuth: store.getState().auth.isAuthenticated,
      };

      console.log('ğŸ“Š Before Logout:', beforeLogout);

      console.log('ğŸ“¤ Step 2: Notifying server of logout...');
      await AuthFlow.logout();

      console.log('ğŸ§¹ Step 3: Clearing client authentication state...');

      const afterLogout = {
        hasToken: !!TokenManager.getStoredTokens().accessToken,
        isAuthenticated: AuthFlow.isAuthenticated(),
        reduxAuth: store.getState().auth.isAuthenticated,
      };

      console.log('ğŸ“Š After Logout:', afterLogout);

      if (!afterLogout.hasToken && !afterLogout.isAuthenticated && !afterLogout.reduxAuth) {
        console.log('âœ… DEMO RESULT: Logout completed successfully - all auth state cleared');
      } else {
        console.log('âš ï¸ DEMO RESULT: Logout incomplete - some auth state remains');
      }

    } catch (error) {
      console.error('ğŸ’¥ DEMO ERROR:', error);
    }

    console.groupEnd();
  }
}

// ========================================
// ğŸ§ª AUTHENTICATION TESTING UTILITIES
// ========================================

export class AuthFlowTester {
  /**
   * Run all authentication flow tests
   */
  static async runAllTests(): Promise<void> {
    console.log('ğŸ§ª Running Complete Authentication Flow Tests...');
    console.log('Note: These tests may require a running backend server');

    const tests = [
      { name: 'Login Flow', test: AuthFlowDemo.demoLoginFlow },
      { name: 'Protected Access', test: AuthFlowDemo.demoProtectedAccessFlow },
      { name: 'Token Refresh', test: AuthFlowDemo.demoTokenRefreshFlow },
      { name: 'Role-Based Access', test: AuthFlowDemo.demoRoleBasedAccess },
      { name: 'Logout Flow', test: AuthFlowDemo.demoLogoutFlow },
    ];

    for (let i = 0; i < tests.length; i++) {
      const { name, test } = tests[i];
      console.log(`\nğŸ”„ Test ${i + 1}/${tests.length}: ${name}`);
      
      try {
        await test();
        await this.wait(1000); // Wait between tests
      } catch (error) {
        console.error(`âŒ Test ${name} failed:`, error);
      }
    }

    console.log('\nğŸ‰ All authentication flow tests completed!');
  }

  /**
   * Test authentication state persistence
   */
  static testStatePersistence(): void {
    console.group('ğŸ’¾ Testing Authentication State Persistence');

    try {
      // Test localStorage persistence
      const testTokens = {
        accessToken: 'test_access_token',
        refreshToken: 'test_refresh_token',
        expiresIn: 3600,
        tokenType: 'Bearer' as const,
      };

      const testUser = {
        id: 'test_user_id',
        email: 'test@example.com',
        name: 'Test User',
        role: 'user' as const,
        emailVerified: true,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
      };

      console.log('ğŸ’¾ Step 1: Storing test authentication data...');
      TokenManager.storeTokens(testTokens, testUser, true);

      console.log('ğŸ” Step 2: Retrieving stored data...');
      const retrieved = TokenManager.getStoredTokens();

      const isValid = 
        retrieved.accessToken === testTokens.accessToken &&
        retrieved.refreshToken === testTokens.refreshToken &&
        retrieved.user?.email === testUser.email;

      console.log('ğŸ“Š Persistence Test Result:', isValid ? 'âœ… PASSED' : 'âŒ FAILED');

      if (isValid) {
        console.log('ğŸ§¹ Step 3: Cleaning up test data...');
        TokenManager.clearTokens();
        console.log('âœ… State persistence test completed successfully');
      }

    } catch (error) {
      console.error('âŒ State persistence test failed:', error);
    }

    console.groupEnd();
  }

  /**
   * Test authentication utilities
   */
  static testAuthUtilities(): void {
    console.group('ğŸ”§ Testing Authentication Utilities');

    try {
      // Test email validation
      const emailTests = [
        { email: 'valid@example.com', expected: true },
        { email: 'invalid-email', expected: false },
        { email: 'another@domain.co.uk', expected: true },
        { email: '@invalid.com', expected: false },
      ];

      console.log('ğŸ“§ Testing email validation...');
      emailTests.forEach(({ email, expected }) => {
        const result = authUtils.isValidEmail(email);
        const passed = result === expected;
        console.log(`${passed ? 'âœ…' : 'âŒ'} Email: ${email} -> ${result} (expected: ${expected})`);
      });

      // Test password strength
      const passwordTests = [
        { password: 'weak', expectedScore: 1 },
        { password: 'StrongPass123!', expectedScore: 5 },
        { password: 'medium123', expectedScore: 3 },
      ];

      console.log('ğŸ”’ Testing password strength...');
      passwordTests.forEach(({ password, expectedScore }) => {
        const result = authUtils.checkPasswordStrength(password);
        const passed = result.score === expectedScore;
        console.log(`${passed ? 'âœ…' : 'âŒ'} Password strength: ${password} -> Score: ${result.score} (expected: ${expectedScore})`);
      });

      console.log('âœ… Authentication utilities test completed');

    } catch (error) {
      console.error('âŒ Auth utilities test failed:', error);
    }

    console.groupEnd();
  }

  /**
   * Test authentication error handling
   */
  static async testErrorHandling(): Promise<void> {
    console.group('âŒ Testing Authentication Error Handling');

    try {
      // Test invalid login
      console.log('ğŸ” Testing invalid login credentials...');
      const loginResult = await AuthFlow.login({
        email: 'invalid@example.com',
        password: 'wrongpassword',
        rememberMe: false,
      });

      if (!loginResult.success) {
        console.log('âœ… Invalid login properly rejected:', loginResult.error);
      } else {
        console.log('âŒ Invalid login should have failed');
      }

      // Test protected access without token
      console.log('ğŸ” Testing protected access without authentication...');
      TokenManager.clearTokens(); // Ensure no token
      
      const accessResult = await AuthGuard.canAccess();
      if (!accessResult) {
        console.log('âœ… Protected access properly denied without authentication');
      } else {
        console.log('âŒ Protected access should have been denied');
      }

      console.log('âœ… Error handling test completed');

    } catch (error) {
      console.error('âŒ Error handling test failed:', error);
    }

    console.groupEnd();
  }

  /**
   * Wait utility for tests
   */
  private static wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ========================================
// ğŸ¯ USAGE EXAMPLES FOR COMPONENTS
// ========================================

export const authFlowExamples = {
  /**
   * Example: React component with authentication
   */
  reactComponentExample: `
// React Component Example
import React, { useState, useEffect } from 'react';
import { AuthFlow, AuthGuard, authUtils } from './authFlow';

function ProtectedComponent() {
  const [isAuthorized, setIsAuthorized] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const checkAuth = async () => {
      const hasAccess = await AuthGuard.canAccess('user');
      setIsAuthorized(hasAccess);
      setIsLoading(false);
    };
    
    checkAuth();
  }, []);

  const handleLogin = async (email, password) => {
    const result = await AuthFlow.login({ email, password, rememberMe: true });
    if (result.success) {
      setIsAuthorized(true);
    }
  };

  const handleLogout = async () => {
    await AuthFlow.logout();
    setIsAuthorized(false);
    window.location.href = '/login';
  };

  if (isLoading) return <div>Checking authentication...</div>;
  if (!isAuthorized) return <div>Access denied. Please login.</div>;

  return (
    <div>
      <h1>Protected Content</h1>
      <button onClick={handleLogout}>Logout</button>
    </div>
  );
}
`,

  /**
   * Example: API service with authentication
   */
  apiServiceExample: `
// API Service with Authentication Example
import { httpClient } from './httpClient';
import { AuthFlow } from './authFlow';

class UserService {
  static async getProfile() {
    // Token automatically included by middleware
    const response = await httpClient.get('/user/profile');
    return response;
  }
  
  static async updateProfile(data) {
    // Middleware handles token refresh if needed
    const response = await httpClient.put('/user/profile', data);
    return response;
  }
  
  static async deleteAccount() {
    // Check if user is authenticated before making request
    if (!AuthFlow.isAuthenticated()) {
      throw new Error('User not authenticated');
    }
    
    const response = await httpClient.delete('/user/account');
    
    if (response.success) {
      // Clear auth state after account deletion
      await AuthFlow.logout();
    }
    
    return response;
  }
}
`,
};

// Export demo functions for easy access
export const authDemos = {
  loginFlow: AuthFlowDemo.demoLoginFlow,
  protectedAccess: AuthFlowDemo.demoProtectedAccessFlow,
  tokenRefresh: AuthFlowDemo.demoTokenRefreshFlow,
  roleAccess: AuthFlowDemo.demoRoleBasedAccess,
  logoutFlow: AuthFlowDemo.demoLogoutFlow,
  runAllTests: AuthFlowTester.runAllTests,
  testPersistence: AuthFlowTester.testStatePersistence,
  testUtilities: AuthFlowTester.testAuthUtilities,
  testErrorHandling: AuthFlowTester.testErrorHandling,
};

export { AuthFlowDemo, AuthFlowTester };
export default authDemos;
