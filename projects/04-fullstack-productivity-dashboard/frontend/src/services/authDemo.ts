/**
 * Authentication Flow Demo & Testing
 * 
 * Demonstrates the complete authentication flow:
 * 🔑 Login Form → Validate Credentials → Generate JWT Token → Store Token
 *      ↑                                                        ↓
 * 🛡️ Protected Access ← Verify Token ← Middleware Check ← Include in Headers
 */

import { AuthFlow, TokenManager, AuthGuard, authUtils } from './authFlow';
import { httpClient } from './httpClient';
import { store } from '../store';

// ========================================
// 🧪 AUTHENTICATION FLOW DEMOS
// ========================================

export class AuthFlowDemo {
  /**
   * Demo 1: Complete Login Flow
   * Shows the full authentication cycle from form submission to token storage
   */
  static async demoLoginFlow(): Promise<void> {
    console.group('🔑 DEMO: Complete Authentication Login Flow');
    
    try {
      console.log('📋 Step 1: User fills login form');
      const loginCredentials = {
        email: 'demo@example.com',
        password: 'securepassword123',
        rememberMe: true,
      };

      console.log('✅ Step 2: Form validation passed');
      console.log('📤 Step 3: Sending credentials to server...');

      // This would normally come from form submission
      const loginResult = await AuthFlow.login(loginCredentials);

      if (loginResult.success) {
        console.log('🎉 Step 4: Login successful!');
        console.log('🔒 Step 5: JWT Token generated by server');
        console.log('💾 Step 6: Token stored in browser storage');
        
        // Show stored authentication data
        const storedData = TokenManager.getStoredTokens();
        console.log('📊 Stored Authentication Data:', {
          hasToken: !!storedData.accessToken,
          hasRefreshToken: !!storedData.refreshToken,
          user: storedData.user?.email,
          expiresAt: storedData.expiryTime ? new Date(storedData.expiryTime).toLocaleString() : null,
        });

        // Show Redux state update
        const authState = store.getState().auth;
        console.log('🔄 Redux State Updated:', {
          isAuthenticated: authState.isAuthenticated,
          userEmail: authState.user?.email,
          hasToken: !!authState.token,
        });

        console.log('✅ DEMO RESULT: Complete login flow successful');
      } else {
        console.log('❌ DEMO RESULT: Login failed -', loginResult.error);
      }

    } catch (error) {
      console.error('💥 DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 2: Protected Access Flow  
   * Shows how authentication middleware handles protected requests
   */
  static async demoProtectedAccessFlow(): Promise<void> {
    console.group('🛡️ DEMO: Protected Access Flow');

    try {
      console.log('📋 Step 1: User attempts to access protected resource');
      console.log('🔍 Step 2: Middleware checks authentication...');

      // Check authentication status
      const isAuthenticated = AuthFlow.isAuthenticated();
      console.log('🔐 Authentication Status:', isAuthenticated);

      if (!isAuthenticated) {
        console.log('❌ Step 3: User not authenticated - redirecting to login');
        console.log('✅ DEMO RESULT: Protected access denied (as expected)');
        console.groupEnd();
        return;
      }

      console.log('✅ Step 3: User is authenticated');
      console.log('📤 Step 4: Making request with auth headers...');

      // Make a protected API request
      const response = await httpClient.get('/protected-resource');

      if (response.success) {
        console.log('🎉 Step 5: Protected resource accessed successfully');
        console.log('📊 Response:', response.data);
        console.log('✅ DEMO RESULT: Protected access granted');
      } else {
        console.log('❌ Step 5: Protected resource access failed');
        console.log('📊 Error:', response.error);
        
        if (response.error?.includes('401')) {
          console.log('🔄 Step 6: Token might be expired, attempting refresh...');
          const refreshed = await AuthFlow.refreshTokens();
          if (refreshed) {
            console.log('✅ Step 7: Token refreshed, access should work now');
          } else {
            console.log('❌ Step 7: Token refresh failed, user needs to login again');
          }
        }
      }

    } catch (error) {
      console.error('💥 DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 3: Token Refresh Flow
   * Shows automatic token refresh when approaching expiry
   */
  static async demoTokenRefreshFlow(): Promise<void> {
    console.group('🔄 DEMO: Token Refresh Flow');

    try {
      const storedData = TokenManager.getStoredTokens();
      
      if (!storedData.accessToken) {
        console.log('❌ No access token found - login required first');
        console.groupEnd();
        return;
      }

      console.log('📋 Step 1: Checking token expiry status...');
      const isExpired = TokenManager.isTokenExpired();
      console.log('⏰ Token Expired:', isExpired);

      if (isExpired) {
        console.log('🔄 Step 2: Token expired, attempting automatic refresh...');
        const refreshResult = await AuthFlow.refreshTokens();

        if (refreshResult) {
          console.log('✅ Step 3: Token refresh successful');
          
          const newStoredData = TokenManager.getStoredTokens();
          console.log('📊 New Token Info:', {
            hasNewToken: !!newStoredData.accessToken,
            newExpiryTime: newStoredData.expiryTime ? new Date(newStoredData.expiryTime).toLocaleString() : null,
          });

          console.log('✅ DEMO RESULT: Token refresh completed successfully');
        } else {
          console.log('❌ Step 3: Token refresh failed');
          console.log('🔓 Step 4: Clearing authentication state...');
          TokenManager.clearTokens();
          console.log('❌ DEMO RESULT: Authentication session ended');
        }
      } else {
        console.log('✅ Token is still valid, no refresh needed');
        const timeUntilExpiry = storedData.expiryTime ? (storedData.expiryTime - Date.now()) / 1000 / 60 : 0;
        console.log(`⏰ Time until expiry: ${Math.round(timeUntilExpiry)} minutes`);
        console.log('✅ DEMO RESULT: Token refresh not needed yet');
      }

    } catch (error) {
      console.error('💥 DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 4: Role-Based Access Control
   * Shows permission checking for different user roles
   */
  static async demoRoleBasedAccess(): Promise<void> {
    console.group('🔐 DEMO: Role-Based Access Control');

    try {
      const currentUser = AuthFlow.getCurrentUser();
      
      if (!currentUser) {
        console.log('❌ No authenticated user found');
        console.groupEnd();
        return;
      }

      console.log('👤 Current User:', {
        name: currentUser.name,
        email: currentUser.email,
        role: currentUser.role,
      });

      // Test different permission levels
      const permissions = ['user', 'admin', 'moderator'];
      
      for (const permission of permissions) {
        console.log(`🔍 Testing access for role: ${permission}`);
        const hasAccess = await AuthGuard.canAccess(permission);
        console.log(`${hasAccess ? '✅' : '❌'} Access ${permission}: ${hasAccess ? 'GRANTED' : 'DENIED'}`);
      }

      console.log('✅ DEMO RESULT: Role-based access control tested');

    } catch (error) {
      console.error('💥 DEMO ERROR:', error);
    }

    console.groupEnd();
  }

  /**
   * Demo 5: Complete Logout Flow
   * Shows proper cleanup of authentication state
   */
  static async demoLogoutFlow(): Promise<void> {
    console.group('🔓 DEMO: Logout Flow');

    try {
      console.log('📋 Step 1: User initiates logout');
      
      const beforeLogout = {
        hasToken: !!TokenManager.getStoredTokens().accessToken,
        isAuthenticated: AuthFlow.isAuthenticated(),
        reduxAuth: store.getState().auth.isAuthenticated,
      };

      console.log('📊 Before Logout:', beforeLogout);

      console.log('📤 Step 2: Notifying server of logout...');
      await AuthFlow.logout();

      console.log('🧹 Step 3: Clearing client authentication state...');

      const afterLogout = {
        hasToken: !!TokenManager.getStoredTokens().accessToken,
        isAuthenticated: AuthFlow.isAuthenticated(),
        reduxAuth: store.getState().auth.isAuthenticated,
      };

      console.log('📊 After Logout:', afterLogout);

      if (!afterLogout.hasToken && !afterLogout.isAuthenticated && !afterLogout.reduxAuth) {
        console.log('✅ DEMO RESULT: Logout completed successfully - all auth state cleared');
      } else {
        console.log('⚠️ DEMO RESULT: Logout incomplete - some auth state remains');
      }

    } catch (error) {
      console.error('💥 DEMO ERROR:', error);
    }

    console.groupEnd();
  }
}

// ========================================
// 🧪 AUTHENTICATION TESTING UTILITIES
// ========================================

export class AuthFlowTester {
  /**
   * Run all authentication flow tests
   */
  static async runAllTests(): Promise<void> {
    console.log('🧪 Running Complete Authentication Flow Tests...');
    console.log('Note: These tests may require a running backend server');

    const tests = [
      { name: 'Login Flow', test: AuthFlowDemo.demoLoginFlow },
      { name: 'Protected Access', test: AuthFlowDemo.demoProtectedAccessFlow },
      { name: 'Token Refresh', test: AuthFlowDemo.demoTokenRefreshFlow },
      { name: 'Role-Based Access', test: AuthFlowDemo.demoRoleBasedAccess },
      { name: 'Logout Flow', test: AuthFlowDemo.demoLogoutFlow },
    ];

    for (let i = 0; i < tests.length; i++) {
      const { name, test } = tests[i];
      console.log(`\n🔄 Test ${i + 1}/${tests.length}: ${name}`);
      
      try {
        await test();
        await this.wait(1000); // Wait between tests
      } catch (error) {
        console.error(`❌ Test ${name} failed:`, error);
      }
    }

    console.log('\n🎉 All authentication flow tests completed!');
  }

  /**
   * Test authentication state persistence
   */
  static testStatePersistence(): void {
    console.group('💾 Testing Authentication State Persistence');

    try {
      // Test localStorage persistence
      const testTokens = {
        accessToken: 'test_access_token',
        refreshToken: 'test_refresh_token',
        expiresIn: 3600,
        tokenType: 'Bearer' as const,
      };

      const testUser = {
        id: 'test_user_id',
        email: 'test@example.com',
        name: 'Test User',
        role: 'user' as const,
        emailVerified: true,
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
      };

      console.log('💾 Step 1: Storing test authentication data...');
      TokenManager.storeTokens(testTokens, testUser, true);

      console.log('🔍 Step 2: Retrieving stored data...');
      const retrieved = TokenManager.getStoredTokens();

      const isValid = 
        retrieved.accessToken === testTokens.accessToken &&
        retrieved.refreshToken === testTokens.refreshToken &&
        retrieved.user?.email === testUser.email;

      console.log('📊 Persistence Test Result:', isValid ? '✅ PASSED' : '❌ FAILED');

      if (isValid) {
        console.log('🧹 Step 3: Cleaning up test data...');
        TokenManager.clearTokens();
        console.log('✅ State persistence test completed successfully');
      }

    } catch (error) {
      console.error('❌ State persistence test failed:', error);
    }

    console.groupEnd();
  }

  /**
   * Test authentication utilities
   */
  static testAuthUtilities(): void {
    console.group('🔧 Testing Authentication Utilities');

    try {
      // Test email validation
      const emailTests = [
        { email: 'valid@example.com', expected: true },
        { email: 'invalid-email', expected: false },
        { email: 'another@domain.co.uk', expected: true },
        { email: '@invalid.com', expected: false },
      ];

      console.log('📧 Testing email validation...');
      emailTests.forEach(({ email, expected }) => {
        const result = authUtils.isValidEmail(email);
        const passed = result === expected;
        console.log(`${passed ? '✅' : '❌'} Email: ${email} -> ${result} (expected: ${expected})`);
      });

      // Test password strength
      const passwordTests = [
        { password: 'weak', expectedScore: 1 },
        { password: 'StrongPass123!', expectedScore: 5 },
        { password: 'medium123', expectedScore: 3 },
      ];

      console.log('🔒 Testing password strength...');
      passwordTests.forEach(({ password, expectedScore }) => {
        const result = authUtils.checkPasswordStrength(password);
        const passed = result.score === expectedScore;
        console.log(`${passed ? '✅' : '❌'} Password strength: ${password} -> Score: ${result.score} (expected: ${expectedScore})`);
      });

      console.log('✅ Authentication utilities test completed');

    } catch (error) {
      console.error('❌ Auth utilities test failed:', error);
    }

    console.groupEnd();
  }

  /**
   * Test authentication error handling
   */
  static async testErrorHandling(): Promise<void> {
    console.group('❌ Testing Authentication Error Handling');

    try {
      // Test invalid login
      console.log('🔍 Testing invalid login credentials...');
      const loginResult = await AuthFlow.login({
        email: 'invalid@example.com',
        password: 'wrongpassword',
        rememberMe: false,
      });

      if (!loginResult.success) {
        console.log('✅ Invalid login properly rejected:', loginResult.error);
      } else {
        console.log('❌ Invalid login should have failed');
      }

      // Test protected access without token
      console.log('🔍 Testing protected access without authentication...');
      TokenManager.clearTokens(); // Ensure no token
      
      const accessResult = await AuthGuard.canAccess();
      if (!accessResult) {
        console.log('✅ Protected access properly denied without authentication');
      } else {
        console.log('❌ Protected access should have been denied');
      }

      console.log('✅ Error handling test completed');

    } catch (error) {
      console.error('❌ Error handling test failed:', error);
    }

    console.groupEnd();
  }

  /**
   * Wait utility for tests
   */
  private static wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ========================================
// 🎯 USAGE EXAMPLES FOR COMPONENTS
// ========================================

export const authFlowExamples = {
  /**
   * Example: React component with authentication
   */
  reactComponentExample: `
// React Component Example
import React, { useState, useEffect } from 'react';
import { AuthFlow, AuthGuard, authUtils } from './authFlow';

function ProtectedComponent() {
  const [isAuthorized, setIsAuthorized] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const checkAuth = async () => {
      const hasAccess = await AuthGuard.canAccess('user');
      setIsAuthorized(hasAccess);
      setIsLoading(false);
    };
    
    checkAuth();
  }, []);

  const handleLogin = async (email, password) => {
    const result = await AuthFlow.login({ email, password, rememberMe: true });
    if (result.success) {
      setIsAuthorized(true);
    }
  };

  const handleLogout = async () => {
    await AuthFlow.logout();
    setIsAuthorized(false);
    window.location.href = '/login';
  };

  if (isLoading) return <div>Checking authentication...</div>;
  if (!isAuthorized) return <div>Access denied. Please login.</div>;

  return (
    <div>
      <h1>Protected Content</h1>
      <button onClick={handleLogout}>Logout</button>
    </div>
  );
}
`,

  /**
   * Example: API service with authentication
   */
  apiServiceExample: `
// API Service with Authentication Example
import { httpClient } from './httpClient';
import { AuthFlow } from './authFlow';

class UserService {
  static async getProfile() {
    // Token automatically included by middleware
    const response = await httpClient.get('/user/profile');
    return response;
  }
  
  static async updateProfile(data) {
    // Middleware handles token refresh if needed
    const response = await httpClient.put('/user/profile', data);
    return response;
  }
  
  static async deleteAccount() {
    // Check if user is authenticated before making request
    if (!AuthFlow.isAuthenticated()) {
      throw new Error('User not authenticated');
    }
    
    const response = await httpClient.delete('/user/account');
    
    if (response.success) {
      // Clear auth state after account deletion
      await AuthFlow.logout();
    }
    
    return response;
  }
}
`,
};

// Export demo functions for easy access
export const authDemos = {
  loginFlow: AuthFlowDemo.demoLoginFlow,
  protectedAccess: AuthFlowDemo.demoProtectedAccessFlow,
  tokenRefresh: AuthFlowDemo.demoTokenRefreshFlow,
  roleAccess: AuthFlowDemo.demoRoleBasedAccess,
  logoutFlow: AuthFlowDemo.demoLogoutFlow,
  runAllTests: AuthFlowTester.runAllTests,
  testPersistence: AuthFlowTester.testStatePersistence,
  testUtilities: AuthFlowTester.testAuthUtilities,
  testErrorHandling: AuthFlowTester.testErrorHandling,
};

export { AuthFlowDemo, AuthFlowTester };
export default authDemos;
